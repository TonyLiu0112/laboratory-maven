package com.liuboyu.jvm;

/**
 * java class 文件字节码探究
 * 演示类(vi :%!xxd 转化成十六进制 :%!xxd -r 还原  )
 * <p>
 * 根据Java虚拟机规范, Class文件格式采用类似C语言的一种伪结构存储数据:
 * 1. 无符号数: 数据基本数据类型, 以u1,u2,u4,u8来分别表示1个字节,2个字节,4个字节,8个字节; 无符号数用于描述数字,索引引用,数据值,或者按照UTF-8编码构成的字符串值
 * 2. 表:以_info结尾的描述.
 * <p>
 * 基本描述:
 * 1. 十六进制用一段描述符描述16bit的数据,所以每个段是2个字节
 * 2. 前4个字节(cafe babe)是class文件的魔数(Magic Number, 通常类似文件名后缀, 可以用于校验文件合法性)
 * 3. 第5、6个字节(0000)标示次版本号, 第7 8个字节标示主版本号.
 * <p>
 * 常量池描述(constant pool)
 * 1. 第5位(9、10个字节)描述常量池容量计数池, 计数从1开始, 0x0016转化成10进制为22, 表示常量池中有21项常量.
 * (为什么计数器不从0开始,是因为0是用来做特殊情况的处理, 在特定情况下需要用0来表达"不引用任何一个常量池项目")
 * 2. 常量池中主要存放两大类常量:
 * 字面量(Literal) --> 比较接近于java里面的常量的概念
 * 符号引用(Symbolic References) 包括 --> 类和接口的全限定名(Fully Qualified Name)、字段名称和描述符(Descriptor)、方法名称和描述符
 * 3. 常量池中的每一项都是一个表(都是以一个u1类型的表示只为代表当前常量属于哪种常量类型.), JDK1.7提供了14种表来支持动态语言的调用.
 * 4. 当虚拟机运行时, 需要从常量池获得对应的符号引用, 再在类创建时或运行时解析、翻译到具体的内存地址.
 * 5. 常量池中的没一项常量都是一个表(1.7总共有14种表结构支持动态语言调用),这些表第一位是一个u1类型的标志位,代表当前这个常量属于哪种常量类型.
 * (由于class文件中的方法、字段都需要引用constant_utf8_info型常量的最大长度也就是Java中方法、字段名的最大长度.而这里的最大长度就是length的最大长度
 * 就是length的最大值,既u2类型能表达的最大值65535,也就是64KB).
 * 6. 通过jdk的 javap -verbose TestClass命令能看到常量池的所有信息, 其中一些在代码中未出现过的字符,比如: 'I', 'V','<init>',他们会被字段表,方法表,属性表
 * 引用到.这些字符用来描述一些不方便使用'固定字节'的内容,比如方法的返回值,参数个数,参数类型.
 * <p>
 * 访问标志(access_flags)
 * 紧跟在常量池之后的两个字节为访问标志,标志用于描述识别一些类或者接口层次的访问信息,包括,这个Class是类还是接口;是否定义为public类型,是否abstract,final.
 * 1. access_flags中一共有16个标志位可以使用,没有使用到的一律标记为0;
 * <p>
 * 类索引(this_class)、父类索引(super_class)、接口索引集合
 * 1. 类索引和父类索引都是一个(因为单继承嘛)u2类型的数据,而接口索引集合是一组(因为多接口实现嘛)u2类型的数据的集合
 * 2. 所有Java类的父类索引都不为0(因为所有类都继承自Object).
 * 3. 类索引和父类索引都指向一个类型为CONSTANT_Class_info类描述符常量.
 * 4. 对于接口而言,入口的第一项为接口计数器,标示索引表的容量. 如果没有实现接口,容量为0.
 * 5. 具体的应用也是指向常量池中的,比如说TestClass的父类索引为4(为什么是4?因为是根据十六进制转十进制算出来的),查找常量池#4发现是java/lang/Object对象
 * <p>
 * 字段表集合
 * 1. 字段表用于描述接口或者类中申明的变量(不包括方法内部的声明的变量).
 * 2. 首先出现的是字段修饰符(access_flags(u2的数据类型)),用户描述字段的作用域.
 * 3. 跟随access_flags的是name_index和descriptor_index, 它们都是对常量池的引用.
 * 4. 什么是全限定名和简单名称: 比如java/lang/Object就是一个全限定名称,仅仅是把包路径的.变成了/;简单名称是指没有类型和参数修饰符的方法或者字段名称;
 * 5. 什么是描述符(字段描述符、方法描述符): 用来描述字段的数据类型 方法的参数列表(包括数量 类型以及顺序) 返回值;
 * 5.1 对于数组类型的描述,每一个维度用[表示,比如一位数据int[]被描述为[I,二维数组String[][]被描述为[[java/lang/String
 * 5.2 对于方法的描述,用先参数列表,后返回值的顺序描述.比如方法void inc()的描述符号为()V;方法toString()的描述符为()String;
 * 6. 紧跟在descriptor_index之后的是一个属性(attributes)集合,用来描述譬如:final static int m = 123;的信息;
 * 7. 字段表不会描述从父类继承到的字段信息;
 * <p>
 * 方法表集合
 * 1. 和字段表集合类似,仅在访问标志和属性表集合的客现象中有所区别,因为volatile关键字和transient关键字不能修饰方法,所以访问标志中不包含这两项
 * 2. 对于方法中的代码,编译器编译成字节码指令后,将指令存放在方法的属性集合里面.
 * 3. Java重载一个方法约束(除了方法名相同意外), 还需要一个不同的特征签名.特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合,也正是因为方法
 * 返回值不会在常量池中有符号引用,所以Java无法根据方法不同的返回值来重载方法.
 * <p>
 * 属性表集合
 * 1. 字段表、方法表,都有自己的属性集合,属性集合定义相对宽松,没有像字段表,方法表一样的强顺序约束,只要和已有属性名不重复,就合法,任何人实现的编译器都可以
 * 加入自定义属性,JVM运行时会忽略掉自己不认识的属性,这主要取决于JVM的版本.(JDK1.7已经定义了21种属性.)
 * 2. Code属性: 出现在方法表的属性集合中(接口或者抽象类可能没有,因为接口和抽象类有无需实现的方法),主要存放java代码编译成的指令集
 * 2.1 max_stack属性代表了操作数栈的最大深度值.JVM根据这个值来分配栈帧的深度.
 * 2.2 max_locals属性代表了局部变量表所需要的存储空间(单位是slot,它是jvm为保存局部变量的最小单位.).
 * 2.3 code: 用于存储字节码指令的一系列字节流,每个字节用u1表示.u1数据类型取值范围是0~255(十进制),所以一直u1类型可以代表256种指令.
 * 2.4 code_length: 虽然定义了u4的长度,但是jvm实际上是做了限制,只能使用最多u2长度.
 * 3. Exception属性: 列举出方法中可能抛出的受查异常,也就是方法描述时throws后面抛出的异常
 * 4. LineNumberTable属性: 用于描述源码的行号和编译后字节码的行号之间的对应关系.
 * 5. LocalVariableTable属性: 用于描述栈帧中局部变量表中的变量与java源码中定义的变量的关系;
 * 6. SourceFile: 用于记录生成这个Class文件的源码文件名称.
 * 7. ConstantValue: 用于通知虚拟机自动为静态变量赋值
 * 8. innerClass: 用户记录内部类与宿主类之间的关系;
 * <p>
 * 类加载器:
 * 1. 双亲委派模式, 加载类的时候先让父类加载器加载,直到启动类加载器,如果父类不能加载,则在交给子类加载,这样保证了jvm中对于同一个类,不会出现不同的副本(比如,
 * 自己定义的一个java原生类(是指java默认的基本数据类型),可以编译,却不能被jvm加载...)
 * 2. 类加载器的实现方法在ClassLoader类的loadClass方法中.
 * 3. 双亲委派模式被破坏(jdk1.2之前,没有这个模型导致破坏.忽略.).
 * 4. OSGi(深入了解这玩意儿才是能完全明白类加载器的精髓啊..............)
 * <p>
 * <p>
 * <p>
 * <p>
 * Created by Tony on 3/17/16.
 */
public class TestClass {

//    static {
//        if (true) {
//            System.out.println(Thread.currentThread() + "init TestClass");
//            while (true) {
//            }
//        }
//    }

    private int m;

    public int inc() {
        return m + 1;
    }

    public static void main(String[] args) {
        String s = new String();
    }

}
